F...FF..F............FF.                                                 [100%]
=================================== FAILURES ===================================
________________ test_load_config_parses_linuxpath_among_noise _________________

tmp_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_load_config_parses_linuxp0')

    def test_load_config_parses_linuxpath_among_noise(tmp_path: Path) -> None:
        cfg = tmp_path / "app.conf"
        cfg.write_text(
            "\n".join(
                [
                    "# comment line",
                    "something=else",
                    "unrelated=123",
                    "linuxpath=/tmp/data.txt",
                    "another=ignored",
                ]
            ),
            encoding="utf-8",
        )
    
>       parsed = load_config(cfg)
                 ^^^^^^^^^^^^^^^^

tests/test_config.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_load_config_parses_linuxp0/app.conf')

    def load_config(config_path: str | Path) -> AppConfig:
        """
        Load configuration from a file.
    
        The config may contain many irrelevant lines.
        The relevant line starts with:
            linuxpath=/some/path/file.txt
            reread_on_query=True|False
            search_algo=linear_scan
    
        Optional SSL:
            ssl_enabled=True|False
            ssl_certfile=/path/to/server.crt
            ssl_keyfile=/path/to/server.key
            ssl_verify=True|False
            ssl_cafile=/path/to/ca_bundle.crt
    
        Rules:
        - Unknown keys are ignored.
        - Blank lines and comments (#...) are ignored.
        - linuxpath is required.
        """
    
        path = Path(config_path)
    
        try:
            raw = path.read_text(encoding="utf-8", errors="replace")
        except FileNotFoundError as exc:
            raise ConfigError(f"Config file not found: {path}") from exc
        except OSError as exc:
            raise ConfigError(
                f"Failed to read config file: {path} ({exc})"
            ) from exc
    
        linuxpath: Path | None = None
        reread_on_query: bool = True
        search_algo: str = "linear_scan"
    
        ssl_enabled: bool = False
        ssl_certfile: Path | None = None
        ssl_keyfile: Path | None = None
        ssl_verify: bool = True
        ssl_cafile: Path | None = None
    
        for line in raw.splitlines():
            stripped = line.strip()
    
            if not stripped or stripped.startswith("#"):
                continue
    
            if stripped.startswith("linuxpath="):
                value = stripped[len("linuxpath="):].strip()
                if not value:
                    raise ConfigError("linuxpath is present but empty")
                linuxpath = Path(value)
                continue
    
            if stripped.startswith("reread_on_query="):
                value = stripped[len("reread_on_query="):].strip()
                reread_on_query = _parse_bool(value)
                continue
    
            if stripped.startswith("search_algo="):
                value = stripped[len("search_algo="):].strip()
                if not value:
                    raise ConfigError("search_algo is present but empty")
                search_algo = value
                continue
    
            # SSL parsing (optional)
            if stripped.startswith("ssl_enabled="):
                value = stripped[len("ssl_enabled="):].strip()
                ssl_enabled = _parse_bool(value)
                continue
    
            if stripped.startswith("ssl_certfile="):
                value = stripped[len("ssl_certfile="):].strip()
                ssl_certfile = Path(value) if value else None
                continue
    
            if stripped.startswith("ssl_keyfile="):
                value = stripped[len("ssl_keyfile="):].strip()
                ssl_keyfile = Path(value) if value else None
                continue
    
            if stripped.startswith("ssl_verify="):
                value = stripped[len("ssl_verify="):].strip()
                ssl_verify = _parse_bool(value)
                continue
    
            if stripped.startswith("ssl_cafile="):
                value = stripped[len("ssl_cafile="):].strip()
                ssl_cafile = Path(value) if value else None
                continue
    
            # Ignore other keys/lines.
    
        if linuxpath is None:
            raise ConfigError("Missing required config entry: linuxpath=")
    
        allowed = {
            "linear_scan",
            "mmap_scan",
            "grep_fx",
            "set_cache",
            "sorted_bisect",
        }
    
        if search_algo not in allowed:
            raise ConfigError(
                f"Unsupported search_algo={search_algo!r}. "
                f"Allowed: {sorted(allowed)}"
            )
    
        # If SSL is enabled, server must have cert + key
        if ssl_enabled:
            if ssl_certfile is None or ssl_keyfile is None:
                raise ConfigError(
                    "ssl_enabled=True requires ssl_certfile=... "
                    "and ssl_keyfile=..."
                )
        # Client verification sanity: if verify is enabled, a cafile is required
        if ssl_verify and ssl_cafile is None:
>           raise ConfigError(
                "ssl_verify=True requires ssl_cafile=... "
                "(for self-signed cert verification)."
            )
E           config.ConfigError: ssl_verify=True requires ssl_cafile=... (for self-signed cert verification).

config.py:170: ConfigError
__________________________ test_load_config_defaults ___________________________

tmp_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_load_config_defaults0')

    def test_load_config_defaults(tmp_path: Path) -> None:
        cfg = tmp_path / "app.conf"
        cfg.write_text("linuxpath=/tmp/data.txt\n", encoding="utf-8")
    
>       parsed = load_config(cfg)
                 ^^^^^^^^^^^^^^^^

tests/test_config.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_load_config_defaults0/app.conf')

    def load_config(config_path: str | Path) -> AppConfig:
        """
        Load configuration from a file.
    
        The config may contain many irrelevant lines.
        The relevant line starts with:
            linuxpath=/some/path/file.txt
            reread_on_query=True|False
            search_algo=linear_scan
    
        Optional SSL:
            ssl_enabled=True|False
            ssl_certfile=/path/to/server.crt
            ssl_keyfile=/path/to/server.key
            ssl_verify=True|False
            ssl_cafile=/path/to/ca_bundle.crt
    
        Rules:
        - Unknown keys are ignored.
        - Blank lines and comments (#...) are ignored.
        - linuxpath is required.
        """
    
        path = Path(config_path)
    
        try:
            raw = path.read_text(encoding="utf-8", errors="replace")
        except FileNotFoundError as exc:
            raise ConfigError(f"Config file not found: {path}") from exc
        except OSError as exc:
            raise ConfigError(
                f"Failed to read config file: {path} ({exc})"
            ) from exc
    
        linuxpath: Path | None = None
        reread_on_query: bool = True
        search_algo: str = "linear_scan"
    
        ssl_enabled: bool = False
        ssl_certfile: Path | None = None
        ssl_keyfile: Path | None = None
        ssl_verify: bool = True
        ssl_cafile: Path | None = None
    
        for line in raw.splitlines():
            stripped = line.strip()
    
            if not stripped or stripped.startswith("#"):
                continue
    
            if stripped.startswith("linuxpath="):
                value = stripped[len("linuxpath="):].strip()
                if not value:
                    raise ConfigError("linuxpath is present but empty")
                linuxpath = Path(value)
                continue
    
            if stripped.startswith("reread_on_query="):
                value = stripped[len("reread_on_query="):].strip()
                reread_on_query = _parse_bool(value)
                continue
    
            if stripped.startswith("search_algo="):
                value = stripped[len("search_algo="):].strip()
                if not value:
                    raise ConfigError("search_algo is present but empty")
                search_algo = value
                continue
    
            # SSL parsing (optional)
            if stripped.startswith("ssl_enabled="):
                value = stripped[len("ssl_enabled="):].strip()
                ssl_enabled = _parse_bool(value)
                continue
    
            if stripped.startswith("ssl_certfile="):
                value = stripped[len("ssl_certfile="):].strip()
                ssl_certfile = Path(value) if value else None
                continue
    
            if stripped.startswith("ssl_keyfile="):
                value = stripped[len("ssl_keyfile="):].strip()
                ssl_keyfile = Path(value) if value else None
                continue
    
            if stripped.startswith("ssl_verify="):
                value = stripped[len("ssl_verify="):].strip()
                ssl_verify = _parse_bool(value)
                continue
    
            if stripped.startswith("ssl_cafile="):
                value = stripped[len("ssl_cafile="):].strip()
                ssl_cafile = Path(value) if value else None
                continue
    
            # Ignore other keys/lines.
    
        if linuxpath is None:
            raise ConfigError("Missing required config entry: linuxpath=")
    
        allowed = {
            "linear_scan",
            "mmap_scan",
            "grep_fx",
            "set_cache",
            "sorted_bisect",
        }
    
        if search_algo not in allowed:
            raise ConfigError(
                f"Unsupported search_algo={search_algo!r}. "
                f"Allowed: {sorted(allowed)}"
            )
    
        # If SSL is enabled, server must have cert + key
        if ssl_enabled:
            if ssl_certfile is None or ssl_keyfile is None:
                raise ConfigError(
                    "ssl_enabled=True requires ssl_certfile=... "
                    "and ssl_keyfile=..."
                )
        # Client verification sanity: if verify is enabled, a cafile is required
        if ssl_verify and ssl_cafile is None:
>           raise ConfigError(
                "ssl_verify=True requires ssl_cafile=... "
                "(for self-signed cert verification)."
            )
E           config.ConfigError: ssl_verify=True requires ssl_cafile=... (for self-signed cert verification).

config.py:170: ConfigError
_______________ test_load_config_parses_reread_on_query_and_algo _______________

tmp_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_load_config_parses_reread0')

    def test_load_config_parses_reread_on_query_and_algo(tmp_path: Path) -> None:
        cfg = tmp_path / "app.conf"
        cfg.write_text(
            "\n".join(
                [
                    "linuxpath=/tmp/data.txt",
                    "reread_on_query=False",
                    "search_algo=linear_scan",
                ]
            )
            + "\n",
            encoding="utf-8",
        )
    
>       parsed = load_config(cfg)
                 ^^^^^^^^^^^^^^^^

tests/test_config.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_load_config_parses_reread0/app.conf')

    def load_config(config_path: str | Path) -> AppConfig:
        """
        Load configuration from a file.
    
        The config may contain many irrelevant lines.
        The relevant line starts with:
            linuxpath=/some/path/file.txt
            reread_on_query=True|False
            search_algo=linear_scan
    
        Optional SSL:
            ssl_enabled=True|False
            ssl_certfile=/path/to/server.crt
            ssl_keyfile=/path/to/server.key
            ssl_verify=True|False
            ssl_cafile=/path/to/ca_bundle.crt
    
        Rules:
        - Unknown keys are ignored.
        - Blank lines and comments (#...) are ignored.
        - linuxpath is required.
        """
    
        path = Path(config_path)
    
        try:
            raw = path.read_text(encoding="utf-8", errors="replace")
        except FileNotFoundError as exc:
            raise ConfigError(f"Config file not found: {path}") from exc
        except OSError as exc:
            raise ConfigError(
                f"Failed to read config file: {path} ({exc})"
            ) from exc
    
        linuxpath: Path | None = None
        reread_on_query: bool = True
        search_algo: str = "linear_scan"
    
        ssl_enabled: bool = False
        ssl_certfile: Path | None = None
        ssl_keyfile: Path | None = None
        ssl_verify: bool = True
        ssl_cafile: Path | None = None
    
        for line in raw.splitlines():
            stripped = line.strip()
    
            if not stripped or stripped.startswith("#"):
                continue
    
            if stripped.startswith("linuxpath="):
                value = stripped[len("linuxpath="):].strip()
                if not value:
                    raise ConfigError("linuxpath is present but empty")
                linuxpath = Path(value)
                continue
    
            if stripped.startswith("reread_on_query="):
                value = stripped[len("reread_on_query="):].strip()
                reread_on_query = _parse_bool(value)
                continue
    
            if stripped.startswith("search_algo="):
                value = stripped[len("search_algo="):].strip()
                if not value:
                    raise ConfigError("search_algo is present but empty")
                search_algo = value
                continue
    
            # SSL parsing (optional)
            if stripped.startswith("ssl_enabled="):
                value = stripped[len("ssl_enabled="):].strip()
                ssl_enabled = _parse_bool(value)
                continue
    
            if stripped.startswith("ssl_certfile="):
                value = stripped[len("ssl_certfile="):].strip()
                ssl_certfile = Path(value) if value else None
                continue
    
            if stripped.startswith("ssl_keyfile="):
                value = stripped[len("ssl_keyfile="):].strip()
                ssl_keyfile = Path(value) if value else None
                continue
    
            if stripped.startswith("ssl_verify="):
                value = stripped[len("ssl_verify="):].strip()
                ssl_verify = _parse_bool(value)
                continue
    
            if stripped.startswith("ssl_cafile="):
                value = stripped[len("ssl_cafile="):].strip()
                ssl_cafile = Path(value) if value else None
                continue
    
            # Ignore other keys/lines.
    
        if linuxpath is None:
            raise ConfigError("Missing required config entry: linuxpath=")
    
        allowed = {
            "linear_scan",
            "mmap_scan",
            "grep_fx",
            "set_cache",
            "sorted_bisect",
        }
    
        if search_algo not in allowed:
            raise ConfigError(
                f"Unsupported search_algo={search_algo!r}. "
                f"Allowed: {sorted(allowed)}"
            )
    
        # If SSL is enabled, server must have cert + key
        if ssl_enabled:
            if ssl_certfile is None or ssl_keyfile is None:
                raise ConfigError(
                    "ssl_enabled=True requires ssl_certfile=... "
                    "and ssl_keyfile=..."
                )
        # Client verification sanity: if verify is enabled, a cafile is required
        if ssl_verify and ssl_cafile is None:
>           raise ConfigError(
                "ssl_verify=True requires ssl_cafile=... "
                "(for self-signed cert verification)."
            )
E           config.ConfigError: ssl_verify=True requires ssl_cafile=... (for self-signed cert verification).

config.py:170: ConfigError
_______________ test_server_responds_with_debug_and_result_line ________________

tmp_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_server_responds_with_debu0')

    def test_server_responds_with_debug_and_result_line(tmp_path: Path) -> None:
        """the actuall test to be done using pytest"""
        port = _get_free_port()
    
        # create a dummy data file and config file
        data_file = tmp_path / "data.txt"
        data_file.write_text("hello\n", encoding="utf-8")
    
        cfg_file = tmp_path / "app.conf"
        # cfg_file.write_text(f"linuxpath={data_file}\n", encoding="utf-8")
        cfg_file.write_text(
            f"linuxpath={data_file}\n"
            "reread_on_query=True\n"
            "search_algo=linear_scan\n",
            encoding="utf-8",
        )
    
        proc = subprocess.Popen(
            [
                sys.executable,
                "-m",
                "server",
                "--host",
                "127.0.0.1",
                "--port",
                str(port),
                "--config",
                str(cfg_file),
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    
        try:
            # Give the server a moment to bind.
            time.sleep(0.3)
    
            # If the process already died, show why.
            rc = proc.poll()
            if rc is not None:
                out, err = proc.communicate(timeout=1)
>               raise RuntimeError(
                    "Server exited early.\n"
                    f"exit_code={rc}\n"
                    f"--- stdout ---\n{out}\n"
                    f"--- stderr ---\n{err}\n"
                )
E               RuntimeError: Server exited early.
E               exit_code=1
E               --- stdout ---
E               
E               --- stderr ---
E               Config error: ssl_verify=True requires ssl_cafile=... (for self-signed cert verification).

tests/test_protocol.py:87: RuntimeError
__________________ test_server_returns_exists_for_exact_line ___________________

tmp_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_server_returns_exists_for0')

    def test_server_returns_exists_for_exact_line(tmp_path: Path) -> None:
        port = _get_free_port()
    
        data_file = tmp_path / "data.txt"
        data_file.write_text("one\ntwo\nthree\n", encoding="utf-8")
    
        cfg_file = tmp_path / "app.conf"
        # cfg_file.write_text(f"linuxpath={data_file}\n", encoding="utf-8")
        cfg_file.write_text(
            f"linuxpath={data_file}\n"
            "reread_on_query=True\n"
            "search_algo=linear_scan\n",
            encoding="utf-8",
        )
    
        proc = subprocess.Popen(
            [
                sys.executable,
                "-m",
                "server",
                "--host",
                "127.0.0.1",
                "--port",
                str(port),
                "--config",
                str(cfg_file),
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    
        try:
            time.sleep(0.3)
    
>           with socket.create_connection(("127.0.0.1", port), timeout=3) as s:
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_server_search_integration.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/socket.py:852: in create_connection
    raise exceptions[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 36463), timeout = 3, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None, *, all_errors=False):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default. When a connection
        cannot be created, raises the last error if *all_errors* is False,
        and an ExceptionGroup of all errors if *all_errors* is True.
        """
    
        host, port = address
        exceptions = []
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/lib/python3.12/socket.py:837: ConnectionRefusedError
__________________ test_server_returns_not_found_for_partial ___________________

tmp_path = PosixPath('/tmp/pytest-of-d333/pytest-11/test_server_returns_not_found_0')

    def test_server_returns_not_found_for_partial(tmp_path: Path) -> None:
        port = _get_free_port()
    
        data_file = tmp_path / "data.txt"
        data_file.write_text("one\ntwo\nthree\n", encoding="utf-8")
    
        cfg_file = tmp_path / "app.conf"
        cfg_file.write_text(f"linuxpath={data_file}\n", encoding="utf-8")
    
        proc = subprocess.Popen(
            [
                sys.executable,
                "-m",
                "server",
                "--host",
                "127.0.0.1",
                "--port",
                str(port),
                "--config",
                str(cfg_file),
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    
        try:
            time.sleep(0.3)
    
>           with socket.create_connection(("127.0.0.1", port), timeout=3) as s:
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_server_search_integration.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/socket.py:852: in create_connection
    raise exceptions[0]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 42193), timeout = 3, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None, *, all_errors=False):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default. When a connection
        cannot be created, raises the last error if *all_errors* is False,
        and an ExceptionGroup of all errors if *all_errors* is True.
        """
    
        host, port = address
        exceptions = []
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/lib/python3.12/socket.py:837: ConnectionRefusedError
=========================== short test summary info ============================
FAILED tests/test_config.py::test_load_config_parses_linuxpath_among_noise - ...
FAILED tests/test_config.py::test_load_config_defaults - config.ConfigError: ...
FAILED tests/test_config.py::test_load_config_parses_reread_on_query_and_algo
FAILED tests/test_protocol.py::test_server_responds_with_debug_and_result_line
FAILED tests/test_server_search_integration.py::test_server_returns_exists_for_exact_line
FAILED tests/test_server_search_integration.py::test_server_returns_not_found_for_partial
6 failed, 18 passed in 1.64s
